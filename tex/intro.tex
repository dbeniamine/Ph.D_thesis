%!TEX encoding=UTF-8 Unicode
\chapter{Introduction}

Scientists from all fields use computing to ease their calculations and run simulations to test their hypothesis.
As computers provides more and more computational power, scientists wants to run always more complex simulations.
Nevertheless, using efficiently a modern computer is not an easy task.
Indeed, since a few decades, computers became more and more parallel.
With this parallelism comes a gain of complexity in computers architectures which are now hierarchical.
As a result, writing an efficient program requires to consider the computer architecture, event if the program is sequential.
\DB{Parler de pattern mÃ©moire ici}

In the end, scientist must not only translate their problems into algorithms but these algorithms must run efficiently in parallel.
Computer scientists from \gls{HPC} field have developed many tools and methods to ease the writing of parallel applications.
Some of these tools are adaptive in the sens that they change the application behavior at runtime to adapt to the machine.
However, they are still relatively complex to use and none of these tools can guarantee good performances.
Therefore, the performances of many applications developed by scientists not specialized in \gls{HPC} can be optimized a posteriori.
% Mouai

The first step to optimize the performance of an application is to find the hotspots, which means the parts of code that are inefficient and understand their nature.
Only at this point it is possible to decide what part of code should be improved and how.
There are many tools designed to analyze the performances of an application, most of them relies on performance counters to collect a trace of the application.
Performance counters are \gls{CPU} register dedicated to performance analysis they enable efficient collection of performance data.
While these counters can be very useful, they consider the memory as a monolithic entity which is not the case on recent architecture.
As a result, tools based on performance counters can help find memory related performance issues, but they are not always able to identify the nature of the issue and they cannot show the pattern responsible for the bad performances.
Thus, specific tools should be used for memory performance analysis.

Analyzing an application performances in regards of the memory raises two challenges:
\begin{itemize}
    \item Memory trace collection
        \begin{itemize}
            \item No HW specific for MPA
            \item Every instruction triggers a mem acc => lot of data to collect
            \item Too much invasivity will change sharing patterns
            \item Reflect the hierarchy
        \end{itemize}
    \item Trace analysis
        \begin{itemize}
            \item Many dimension / point of view
            \item How to extract pertinent data
        \end{itemize}
\end{itemize}

Experiments:
\begin{itemize}
    \item Performance analysis => Experiment
    \item Experiment in computer science
        \begin{itemize}
            \item How to measure perfs
            \item How to compare perfs
        \end{itemize}
    \item This thesis => experimental / memory analysis
\end{itemize}

\section{Contributions}
\subsection{Memory traces collection}
\subsection{Memory traces analysis}
\section{Thesis organization}

\begin{itemize}
    \item  \chap{perf}: Sofa study case + expe methodo
    \item  \chap{mem}: Memory
    \item  \chap{tabarnac}: \gls{Tabarnac}
    \item  \chap{moca}: \gls{Moca}
    \item  \chap{analyzing}: analyzing
    \item  \chap{cncl}: Conclusions
\end{itemize}
% vim: et si sta lbr  sw=4 ts=4 spelllang=en_us
